# -*- coding: utf-8 -*-
"""Untitled19.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QrHlLu9RY4BVQLVEgbIaJFNhJ8HnF5jK

# **Anime Recommendation System**

---

*oleh: [Zahwa Genoveva](https://www.dicoding.com/users/zahwa_genoveva_vwyu/academies)*

*Proyek Submission 2 - Machine Learning
Terapan Dicoding*
<center>
<img src="https://cloudfront-us-east-1.images.arcpublishing.com/infobae/AK5OFYSU3RDA5KJOIQDN4MXQRQ.jpg" align="justify">
</center>

## **1. Mengimpor pustaka/modul python yang dibutuhkan**
---
"""

# Import library dasar
import kagglehub
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from IPython.display import display, HTML

"""## **2. Data Understanding**
---

Data Understanding adalah langkah awal dalam proses analisis data yang bertujuan untuk mengumpulkan, menjelajahi, dan memahami data yang tersedia.

### **2.1 Menyiapkan kredensial akun Kaggle**
"""

from google.colab import files
files.upload()  # Jalankan ini untuk mengunggah file kaggle.json Anda

# Buat direktori .kaggle dan pindahkan file kaggle.json
!mkdir -p ~/.kaggle
!mv kaggle.json ~/.kaggle/

# Atur izin untuk kaggle.json
!chmod 600 ~/.kaggle/kaggle.json

"""### **2.2 Mengunduh dan Menyiapkan Dataset**

![Image of Dataset](https://github.com/user-attachments/assets/7b575bbb-4e3f-412b-8620-8f1a087903c9)
ðŸ“Š Informasi dataset dapat dilihat pada tabel di bawah ini:


| **Jenis**      | **Keterangan**                                                                                           |
|----------------|----------------------------------------------------------------------------------------------------------|
| **Title**      | Anime Dataset 2023                                                                                           |
| **Source**     | Kaggle    
| Sumber                      | [Kaggle Dataset : Anime Dataset 2023](https://www.kaggle.com/datasets/dbdmobile/myanimelist-dataset/data?select=anime-filtered.csv) |                                                                                            |
| **Maintainer** | [Sajid](https://www.kaggle.com/dbdmobile) âš¡                                                                                |
| **License**    | Database: Open Database, Contents: Database Contents                                                                         |
| **Visibility** | Publik                                                                                                |
| **Tags**       | Arts and Entertainment, Movies and TV Shows, Anime and Manga, Popular Culture, Japan       |
| **Usability**  | 10.00                                                                                                   |
"""

# Unduh dataset dari Kaggle
!kaggle datasets download -d dbdmobile/myanimelist-dataset

# Ekstrak file zip
import zipfile

with zipfile.ZipFile("myanimelist-dataset.zip", 'r') as zip_ref:
    zip_ref.extractall("anime_dataset")

df = pd.read_csv('/content/anime_dataset/anime-filtered.csv')

"""### **2.3 Exploratory Data Analysis (EDA)**

Exploratory Data Analysis (EDA) adalah langkah awal dalam analisis data yang bertujuan untuk memahami dan menggali informasi dari dataset sebelum melakukan analisis lebih lanjut atau modeling. Tujuan utama EDA adalah membantu melihat data sebelum membuat asumsi apa pun. EDA dapat membantu mengidentifikasi kesalahan yang jelas, serta memahami pola dalam data dengan lebih baik, mendeteksi outlier atau kejadian yang tidak wajar, dan menemukan hubungan yang menarik di antara variabel.

**2.2.1 EDA - Deskripsi Variabel**

Deskripsi Variabel dalam konteks Exploratory Data Analysis (EDA) adalah langkah di mana kita menganalisis dan menjelaskan karakteristik dari setiap variabel dalam dataset.
"""

df

"""Kode berikut akan menampilkan Beberapa Baris Pertama Data"""

df.head()

"""#### Mengecek data apakah memiliki missing value atau tidak"""

# Menampilkan informasi dasar tentang dataset
df.info()

df.describe()

"""Menampilkan nama-nama kolom di DataFrame df sebagai referensi untuk mengetahui kolom-kolom yang tersedia"""

print('Jumlah Entri (Name):', len(df['Name'].unique()))
print('Jenis-Jenis Kategori (Genres):', df['Genres'].unique())

# Tampilkan kolom yang ada dalam DataFrame
print(df.columns)

"""Memeriksa Jumlah Nilai Non-Null per Kolom"""

for i, (nama_kolom, jumlah) in enumerate(df.notnull().sum().items(), 1):
    print(f"Kolom {i:2d}: {nama_kolom} - Berjumlah: {jumlah}")

"""Mencari data apakah ada data kosong atau tidak"""

print("\nMissing values per column:")
print(df.isnull().sum())

"""ternyata dari data diatas terdapat data kosong pada kolom Ranked yaitu 1721, maka dilakukanlah pembersihan missing value dengan fungsi dropna()

**2.2.2 Visualisasi**

Membuat pie chart untuk menampilkan distribusi jumlah anime berdasarkan tipe
"""

import matplotlib.pyplot as plt

# Menghitung jumlah anime berdasarkan tipe
type_counts = df['Type'].value_counts()

# Membuat pie chart
plt.figure(figsize=(10, 8))
colors = ['#FF9999', '#66B3FF', '#99FF99', '#FFCC99', '#FFD700']  # Palet warna lembut

# Membuat pie chart dengan opsi lebih baik
plt.pie(type_counts,
        labels=type_counts.index,
        autopct='%1.1f%%',
        startangle=140,
        colors=colors,
        explode=[0.1]*len(type_counts),  # Memisahkan irisan agar lebih jelas
        shadow=True,  # Menambahkan bayangan
        textprops={'fontsize': 12, 'color': 'black'})  # Menyesuaikan properti teks

plt.title('Distribusi Jumlah Anime Berdasarkan Tipe', fontsize=16, fontweight='bold')
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
plt.show()

"""Mengambil Sampel Data dan Menampilkan Anime dengan Rating Tertinggi"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Misalkan df adalah DataFrame yang berisi data anime
sample_df = df.sample(n=1000, random_state=42).copy()  # Ambil sampel
sample_df['Score'] = sample_df['Score'].replace('Unknown', pd.NA).astype(float)  # Ganti 'Unknown' dengan NaN dan konversi

# Mengambil 20 anime dengan rating tertinggi
top_20_anime = sample_df.sort_values(by='Score', ascending=False).head(20)

# Plotting
plt.figure(figsize=(16, 10))
sns.barplot(data=top_20_anime, x='Score', y='Name', palette='coolwarm', hue='Name', legend=False)

# Penambahan judul dan label
plt.title('Top 20 Anime with Highest Ratings', fontsize=24, fontweight='bold')
plt.xlabel('Average Rating', fontsize=18)
plt.ylabel('Title of Anime', fontsize=18)

# Anotasi pada setiap bar
for index, value in enumerate(top_20_anime['Score']):
    plt.text(value, index, f'{value:.2f}', va='center', ha='left')

plt.grid(axis='x', linestyle='--', alpha=0.7)
plt.show()

"""Visualisasi 10 Genre Anime Terbanyak"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Sample DataFrame
sample_size = 1000
sample_df = df.sample(n=sample_size, random_state=42)

# Counting genre occurrences
genre_counts = sample_df['Genres'].str.get_dummies(sep=', ').sum().reset_index()
genre_counts.columns = ['Genre', 'Count']

# Taking the top 10 genres
top_genres = genre_counts.sort_values(by='Count', ascending=False).head(10)

# Set the visual style
sns.set(style="whitegrid")
plt.figure(figsize=(12, 6))

# Plotting the bar plot
bar_plot = sns.barplot(data=top_genres, x='Count', y='Genre', palette='viridis', hue='Genre', dodge=False)

# Adding title and labels with enhanced font styles
plt.title('10 Genre Anime Terbanyak', fontsize=24, fontweight='bold', color='#2c3e50')
plt.xlabel('Jumlah Anime', fontsize=18, color='#34495e')
plt.ylabel('Genre', fontsize=18, color='#34495e')

# Adding value annotations on the bars
for p in bar_plot.patches:
    bar_plot.annotate(f'{int(p.get_width())}',
                      (p.get_width() + 5, p.get_y() + p.get_height() / 2),
                      ha='center', va='center', fontsize=14, color='black')

# Removing the legend
plt.legend([],[], frameon=False)

# Adjusting x-ticks for better visibility
plt.xticks(fontsize=14, color='#34495e')
plt.yticks(fontsize=14, color='#34495e')

# Display the plot
plt.show()

"""# **3. Data Preparation**
---

Mengecek jumlah baris duplikat pada DataFrame
"""

df.duplicated().sum()

"""Hasil dari df.shape adalah (14952, 25), yang berarti:

14952: Jumlah baris dalam DataFrame. 25: Jumlah kolom dalam DataFrame.

Jadi, DataFrame df memiliki 14952 baris data dan 25 kolom variabel.
"""

df.shape

"""memeriksa jumlah nilai yang hilang (missing values) dalam kolom yang akan digunakan datanya seperti Name, Score, Genres, Type, sypnopsis, Studios, Episodes, dan Rating"""

missing_values = df[['Name', 'Score', 'Genres', 'Type', 'sypnopsis', 'Studios', 'Episodes', 'Rating']].isnull().sum()
print("Missing values per column:")
print(missing_values)

"""Menghapus baris dengan nilai yang hilang"""

df_cleaned = df.dropna(subset=['Name', 'Score', 'Genres', 'Type', 'sypnopsis', 'Studios', 'Episodes', 'Rating'])

"""Mengecek kembali nilai yang hilang setelah dropna()"""

missing_values_after = df_cleaned[['Name', 'Score', 'Genres', 'Type', 'sypnopsis', 'Studios', 'Episodes', 'Rating']].isnull().sum()
print("\nMissing values per column setelah penanganan:")
print(missing_values_after)

df_cleaned.reset_index(drop=True, inplace=True)

print("\nJumlah data setelah menghapus baris dengan nilai hilang:", df_cleaned.shape[0])

"""terlihat sebanyak 13602 data yang telah dibersihkan

Selanjutnya kode berikut akan menampilkan informasi tentang DataFrame yang telah dibersihkan
"""

print("\nCleaned DataFrame Info:")
df_cleaned.info()

"""Output menunjukkan lima baris pertama dari DataFrame yang berisi informasi mengenai data anime"""

print("\nCleaned DataFrame Head:")
df_cleaned.head()

df_cleaned.shape

"""Dari output yang dihasilkan (13602, 25) berarti DataFrame df_cleaned memiliki 13602 baris dan 25 kolom."""

# Memeriksa kolom yang tersedia dalam DataFrame
print("Kolom yang tersedia:", df.columns.tolist())

unwanted_columns = [
    'anime_id', 'English name', 'Japanese name', 'Aired', 'Premiered',
    'Producers', 'Licensors', 'Source', 'Duration', 'Ranked',
    'Popularity', 'Members', 'Favorites', 'Watching',
    'Completed', 'On-Hold', 'Dropped'
]

"""Kode ini menghapus kolom-kolom yang tidak diperlukan dalam analisis lebih lanjut."""

df = df.drop(columns=unwanted_columns, errors='ignore')

"""Kode ini menampilkan DataFrame df setelah penghapusan kolom yang tidak relevan. Langkah ini memungkinkan kita memeriksa apakah kolom-kolom yang tidak diperlukan telah berhasil dihapus dan memastikan hanya kolom yang relevan yang tersisa."""

df

"""## **4. Modeling**
---

Untuk model kali ini kita akan menggunakan Content Based Filtering dimana tujuan model ini adalah mencari similarity antara anime.

Membuat Fitur TF-IDF dari Kolom 'Genres'
"""

tfidf_vectorizer = TfidfVectorizer()
tfidf_matrix = tfidf_vectorizer.fit_transform(df['Genres'])

"""Menghitung Matriks Kemiripan Kosinus"""

cosine_sim = cosine_similarity(tfidf_matrix)

"""Membuat DataFrame untuk Kemiripan"""

cosine_sim_df = pd.DataFrame(cosine_sim, index=df['Name'], columns=df['Name'])
print("Shape dari cosine similarity matrix:", cosine_sim_df.shape)

"""Membuat Fungsi Rekomendasi Anime"""

def anime_recommendations(anime_name, similarity_data=cosine_sim_df, items=df[['Name', 'Score', 'Genres', 'sypnopsis', 'Type', 'Episodes', 'Studios', 'Rating']], k=5):


    index = similarity_data.loc[:,anime_name].to_numpy().argpartition(
        range(-1, -k, -1))


    closest = similarity_data.columns[index[-1:-(k+2):-1]]
    closest = closest.drop(anime_name, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

"""fungsi ini mencari anime serupa menggunakan matriks kemiripan kosinus, kemudian mengembalikan DataFrame berisi rekomendasi lengkap dengan informasi tambahan"""

df[df.Name.eq('One Piece')]

anime_recommendations('Doraemon')

"""Kode berikut akan mengaktifkan antarmuka interaktif untuk pengguna."""

import pandas as pd
from IPython.display import display, HTML

def anime_recommendations(anime_name, similarity_data, items, k=5):
    """Dapatkan rekomendasi anime berdasarkan data kemiripan."""
    index = similarity_data.loc[:, anime_name].to_numpy().argpartition(range(-1, -k, -1))
    closest = similarity_data.columns[index[-1:-(k+1):-1]].drop(anime_name, errors='ignore')
    return items[items['Name'].isin(closest)].head(k)

def main():
    anime_name = input("Masukkan nama anime: ").strip().lower()
    df_lower = df.assign(Name=df['Name'].str.lower())

    if anime_name in df_lower['Name'].values:
        recommendations = anime_recommendations(
            anime_name.capitalize(),
            cosine_sim_df,
            df[['Name', 'Score', 'Genres', 'sypnopsis', 'Type', 'Episodes', 'Studios', 'Rating']]
        )
        display(HTML(recommendations.to_html(index=False, justify='center')))
    else:
        print(f"Anime '{anime_name.capitalize()}' tidak ditemukan.")

if __name__ == "__main__":
    main()

"""Menampilkan Nama-Nama Anime dalam Dataset"""

animedf_name = pd.DataFrame({'Name': df['Name']})
print(animedf_name.head())

"""## **5. Evaluation**
---

Untuk evaluasi content based filtering, kita dapat menggunakan precision@k dalam menentukan apakah rekomendasi relevan atau tidak
"""

anime_name = 'Doraemon'  # Replace with any anime name of choice

# Get recommendations
recommendations = anime_recommendations(
    anime_name,
    similarity_data=cosine_sim_df,
    items=df[['Name', 'Score', 'Genres', 'sypnopsis', 'Type', 'Episodes', 'Studios', 'Rating']],
    k=10  # Get top 10 recommendations
)

# Check if recommendations were retrieved
if not recommendations.empty:
    k = 10  # Number of recommendations to evaluate
    threshold = 5  # Define the rating threshold for relevance

    # Extract the ratings from the recommended anime DataFrame
    anime_ratings = recommendations['Score'].values  # Using the 'Score' column from recommendations

    # Determine which ratings are above the threshold
    anime_relevances = anime_ratings > threshold

    # Calculate precision
    precision = len(anime_ratings[anime_relevances]) / k if k > 0 else 0
    print(f'The precision of the recommendation system is {precision:.1%}')
else:
    print(f"No recommendations found for '{anime_name}'.")